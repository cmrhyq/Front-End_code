/**
 * tdesign v0.41.1
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var defineProperty = require('../../_chunks/dep-4eb93341.js');
var slicedToArray = require('../../_chunks/dep-9c5d4f93.js');
var React = require('react');
var isNumber = require('../../_chunks/dep-364d4c00.js');
var _common_js_table_setColumnWidthByDrag = require('../../_common/js/table/set-column-width-by-drag.js');
var _common_js_table_recalculateColumnWidth = require('../../_common/js/table/recalculate-column-width.js');
require('../../_chunks/dep-2205decf.js');
require('../../_chunks/dep-61a8a7b0.js');
require('../../_chunks/dep-2a90f794.js');
require('../../_chunks/dep-1fff9729.js');
require('../../_common/js/table/utils.js');
require('../../_chunks/dep-53ba6729.js');
require('../../_chunks/dep-aab723b3.js');

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty._defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var DEFAULT_MIN_WIDTH = 80;
var DEFAULT_MAX_WIDTH = 600;
function useColumnResize(tableContentRef, refreshTable, getThWidthList, updateThWidthList) {
  var resizeLineRef = React.useRef();
  var notCalculateWidthCols = React.useRef([]);
  var effectColMap = React.useRef({});

  var setEffectColMap = function setEffectColMap(nodes, parent) {
    if (!nodes) return;
    nodes.forEach(function (n, index) {
      var parentPrevCol = parent ? effectColMap.current[parent.colKey].prev : nodes[index + 1];
      var parentNextCol = parent ? effectColMap.current[parent.colKey].next : nodes[index - 1];
      var prev = index === 0 ? parentPrevCol : nodes[index - 1];
      var next = index === nodes.length - 1 ? parentNextCol : nodes[index + 1];
      effectColMap.current[n.colKey] = {
        prev: prev,
        next: next
      };
      setEffectColMap(n.children, n);
    });
  };

  var resizeLineParams = {
    isDragging: false,
    draggingCol: null,
    draggingStart: 0,
    effectCol: null
  };

  var _useState = React.useState({
    display: "none",
    left: "10px",
    height: "10px",
    bottom: "0"
  }),
      _useState2 = slicedToArray._slicedToArray(_useState, 2),
      resizeLineStyle = _useState2[0],
      setResizeLineStyle = _useState2[1];

  var setNotCalculateWidthCols = function setNotCalculateWidthCols(colKeys) {
    notCalculateWidthCols.current = colKeys;
  };

  var resizeLineLeft = "";

  var onColumnMouseover = function onColumnMouseover(e) {
    if (!resizeLineRef.current) return;
    var target = e.target.closest("th");
    var targetBoundRect = target.getBoundingClientRect();

    if (!resizeLineParams.isDragging) {
      var distance = 8;

      if (targetBoundRect.right - e.pageX <= distance) {
        target.style.cursor = "col-resize";
        resizeLineParams.draggingCol = target;
        resizeLineParams.effectCol = "next";
      } else if (e.pageX - targetBoundRect.left <= distance) {
        var prevEl = target.previousElementSibling;

        if (prevEl) {
          target.style.cursor = "col-resize";
          resizeLineParams.draggingCol = prevEl;
          resizeLineParams.effectCol = "prev";
        } else {
          target.style.cursor = "";
          resizeLineParams.draggingCol = null;
          resizeLineParams.effectCol = null;
        }
      } else {
        target.style.cursor = "";
        resizeLineParams.draggingCol = null;
        resizeLineParams.effectCol = null;
      }
    }
  };

  var onColumnMousedown = function onColumnMousedown(e, col) {
    var _tableContentRef$curr;

    if (!resizeLineParams.draggingCol) return;

    var getMinMaxColWidth = function getMinMaxColWidth(col2, effectPrevCol2) {
      var _targetCol$resize, _targetCol$resize2;

      var targetCol = null;

      if (resizeLineParams.effectCol === "next") {
        targetCol = col2;
      } else {
        targetCol = effectPrevCol2;
      }

      var propMinWidth = isNumber.isNumber_1(targetCol.minWidth) ? targetCol.minWidth : parseFloat(targetCol.minWidth);
      return {
        minColWidth: Math.max(((_targetCol$resize = targetCol.resize) === null || _targetCol$resize === void 0 ? void 0 : _targetCol$resize.minWidth) || DEFAULT_MIN_WIDTH, propMinWidth || DEFAULT_MIN_WIDTH),
        maxColWidth: ((_targetCol$resize2 = targetCol.resize) === null || _targetCol$resize2 === void 0 ? void 0 : _targetCol$resize2.maxWidth) || DEFAULT_MAX_WIDTH
      };
    };

    var target = resizeLineParams.draggingCol;
    var targetBoundRect = target.getBoundingClientRect();
    var tableBoundRect = (_tableContentRef$curr = tableContentRef.current) === null || _tableContentRef$curr === void 0 ? void 0 : _tableContentRef$curr.getBoundingClientRect();
    var resizeLinePos = targetBoundRect.right - tableBoundRect.left;
    var colLeft = targetBoundRect.left - tableBoundRect.left;
    var effectNextCol = effectColMap.current[col.colKey].next;
    var effectPrevCol = effectColMap.current[col.colKey].prev;

    var _getMinMaxColWidth = getMinMaxColWidth(col, effectPrevCol),
        minColWidth = _getMinMaxColWidth.minColWidth,
        maxColWidth = _getMinMaxColWidth.maxColWidth;

    var minResizeLineLeft = colLeft + minColWidth;
    var maxResizeLineLeft = colLeft + maxColWidth;
    resizeLineParams.isDragging = true;
    resizeLineParams.draggingStart = e.pageX || 0;
    var parent = tableContentRef.current.parentElement.getBoundingClientRect();
    var resizeLineBottom = "".concat(parent.bottom - tableBoundRect.bottom, "px");

    if (resizeLineRef !== null && resizeLineRef !== void 0 && resizeLineRef.current) {
      setResizeLineStyle({
        display: "block",
        left: "".concat(resizeLinePos, "px"),
        height: "".concat(tableBoundRect.bottom - targetBoundRect.top, "px"),
        bottom: resizeLineBottom
      });
    }

    var onDragOver = function onDragOver(e2) {
      if (resizeLineParams.isDragging) {
        var left = resizeLinePos + e2.x - resizeLineParams.draggingStart;
        var lineLeft = "".concat(Math.min(Math.max(left, minResizeLineLeft), maxResizeLineLeft), "px");
        setResizeLineStyle({
          display: "block",
          left: lineLeft,
          height: "".concat(tableBoundRect.bottom - targetBoundRect.top, "px"),
          bottom: resizeLineBottom
        });
        resizeLineLeft = lineLeft;
      }
    };

    var onDragEnd = function onDragEnd() {
      if (resizeLineParams.isDragging) {
        var width = Math.ceil(parseInt(resizeLineLeft, 10) - colLeft) || 0;

        if (width <= minColWidth) {
          width = minColWidth;
        } else if (width >= maxColWidth) {
          width = maxColWidth;
        }

        if (resizeLineParams.effectCol === "next") {
          _common_js_table_setColumnWidthByDrag["default"](col, width, effectNextCol, {
            getThWidthList: getThWidthList,
            DEFAULT_MIN_WIDTH: DEFAULT_MIN_WIDTH
          }, function (updateMap, notCalculateCols) {
            updateThWidthList(updateMap);
            setNotCalculateWidthCols(notCalculateCols);
          });
        } else if (resizeLineParams.effectCol === "prev") {
          _common_js_table_setColumnWidthByDrag["default"](effectPrevCol, width, col, {
            getThWidthList: getThWidthList,
            DEFAULT_MIN_WIDTH: DEFAULT_MIN_WIDTH
          }, function (updateMap, notCalculateCols) {
            updateThWidthList(updateMap);
            setNotCalculateWidthCols(notCalculateCols);
          });
        }

        resizeLineParams.isDragging = false;
        resizeLineParams.draggingCol = null;
        resizeLineParams.effectCol = null;
        target.style.cursor = "";
        setResizeLineStyle(_objectSpread(_objectSpread({}, resizeLineStyle), {}, {
          display: "none",
          left: "0"
        }));
        document.removeEventListener("mousemove", onDragOver);
        document.removeEventListener("mouseup", onDragEnd);
        document.onselectstart = null;
        document.ondragstart = null;
      }

      refreshTable();
    };

    document.addEventListener("mouseup", onDragEnd);
    document.addEventListener("mousemove", onDragOver);

    document.onselectstart = function () {
      return false;
    };

    document.ondragstart = function () {
      return false;
    };
  };

  var recalculateColWidth = function recalculateColWidth(columns, thWidthList, tableLayout, tableElmWidth) {
    _common_js_table_recalculateColumnWidth["default"](columns, thWidthList, tableLayout, tableElmWidth, notCalculateWidthCols.current, function (widthMap) {
      updateThWidthList(widthMap);

      if (notCalculateWidthCols.current.length) {
        notCalculateWidthCols.current = [];
      }
    });
  };

  return {
    resizeLineRef: resizeLineRef,
    resizeLineStyle: resizeLineStyle,
    onColumnMouseover: onColumnMouseover,
    onColumnMousedown: onColumnMousedown,
    recalculateColWidth: recalculateColWidth,
    setEffectColMap: setEffectColMap
  };
}

exports["default"] = useColumnResize;
//# sourceMappingURL=useColumnResize.js.map
