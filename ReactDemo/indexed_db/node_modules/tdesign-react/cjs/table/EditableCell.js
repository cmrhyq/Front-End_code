/**
 * tdesign v0.41.1
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var toConsumableArray = require('../_chunks/dep-8052f095.js');
var _typeof = require('../_chunks/dep-2a90f794.js');
var defineProperty = require('../_chunks/dep-4eb93341.js');
var slicedToArray = require('../_chunks/dep-9c5d4f93.js');
var React = require('react');
var get = require('../_chunks/dep-65cb34d8.js');
var _baseSet = require('../_chunks/dep-55c5ba71.js');
var isFunction = require('../_chunks/dep-53ba6729.js');
var tdesignIconsReact = require('tdesign-icons-react');
var classNames = require('classnames');
var hooks_useGlobalIcon = require('../hooks/useGlobalIcon.js');
var table_TR = require('./TR.js');
var form_formModel = require('../form/formModel.js');
var _common_js_log_log = require('../_common/js/log/log.js');
require('../_chunks/dep-2205decf.js');
require('../_chunks/dep-606cfe2a.js');
require('../_chunks/dep-8329ea23.js');
require('../_chunks/dep-8f18a7c4.js');
require('../_chunks/dep-09805e35.js');
require('../_chunks/dep-61a8a7b0.js');
require('../_chunks/dep-1fff9729.js');
require('../_chunks/dep-46cf36fd.js');
require('../_chunks/dep-f5e18a2f.js');
require('../_chunks/dep-aab723b3.js');
require('../_chunks/dep-384b291c.js');
require('../_chunks/dep-afce8659.js');
require('../_chunks/dep-72020528.js');
require('../_chunks/dep-ad854ba5.js');
require('../_chunks/dep-9cd0fde8.js');
require('../hooks/useConfig.js');
require('../_chunks/dep-4344eec8.js');
require('../_chunks/dep-fe984d70.js');
require('../_chunks/dep-a0b5d8f6.js');
require('../_chunks/dep-12656997.js');
require('../_chunks/dep-bb60493d.js');
require('../_chunks/dep-eebdbd74.js');
require('../_chunks/dep-d3ad6e52.js');
require('../_chunks/dep-aafeb50a.js');
require('../_chunks/dep-6fa7a9e9.js');
require('../_chunks/dep-994ec160.js');
require('../_chunks/dep-9429a38a.js');
require('../_common/js/global-config/locale/zh_CN.js');
require('../_common/js/global-config/default-config.js');
require('./utils.js');
require('./hooks/useFixed.js');
require('../_common/js/utils/helper.js');
require('../_chunks/dep-1a0462cc.js');
require('../_common/js/utils/getScrollbarWidth.js');
require('../_util/dom.js');
require('raf');
require('../_chunks/dep-9a2dbbb1.js');
require('../_util/easing.js');
require('../hooks/useDebounce.js');
require('lodash');
require('../_util/usePersistFn.js');
require('./hooks/useClassName.js');
require('./Ellipsis.js');
require('../tooltip/index.js');
require('../tooltip/Tooltip.js');
require('../popup/index.js');
require('../popup/Popup.js');
require('react-transition-group');
require('react-popper');
require('../hooks/useControlled.js');
require('../_chunks/dep-c76c2a08.js');
require('../_chunks/dep-dc6c808e.js');
require('../_chunks/dep-76deafcc.js');
require('../_util/noop.js');
require('../_util/useAnimation.js');
require('../common/Portal.js');
require('react-dom');
require('../popup/hooks/useTrigger.js');
require('react-is');
require('../popup/utils/ref.js');
require('../_util/composeRefs.js');
require('../popup/utils/transition.js');
require('../_util/useMutationObserver.js');
require('../_chunks/dep-db2b3323.js');
require('../_chunks/dep-52c5813c.js');
require('../_util/useWindowSize.js');
require('../popup/defaultProps.js');
require('../tooltip/defaultProps.js');
require('./hooks/useLazyLoad.js');
require('../_common/js/utils/observe.js');
require('./hooks/useRowspanAndColspan.js');
require('../_chunks/dep-266b1890.js');
require('../_chunks/dep-ca4cc26d.js');
require('../_chunks/dep-4fb39763.js');
require('../_chunks/dep-364d4c00.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);

var baseSet = _baseSet._baseSet;
/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */

function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

var set_1 = set;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty._defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var EditableCell = function EditableCell(props) {
  var _props$col$edit, _col$edit3, _errorList$, _errorList$2;

  var row = props.row,
      col = props.col,
      rowIndex = props.rowIndex,
      colIndex = props.colIndex,
      errors = props.errors,
      editable = props.editable,
      tableBaseClass = props.tableBaseClass;

  var _useGlobalIcon = hooks_useGlobalIcon["default"]({
    Edit1Icon: tdesignIconsReact.Edit1Icon
  }),
      Edit1Icon = _useGlobalIcon.Edit1Icon;

  var tableEditableCellRef = React.useRef(null);

  var _useState = React.useState(((_props$col$edit = props.col.edit) === null || _props$col$edit === void 0 ? void 0 : _props$col$edit.defaultEditable) || false),
      _useState2 = slicedToArray._slicedToArray(_useState, 2),
      isEdit = _useState2[0],
      setIsEdit = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = slicedToArray._slicedToArray(_useState3, 2),
      editValue = _useState4[0],
      setEditValue = _useState4[1];

  var _useState5 = React.useState([]),
      _useState6 = slicedToArray._slicedToArray(_useState5, 2),
      errorList = _useState6[0],
      setErrorList = _useState6[1];

  var getCurrentRow = function getCurrentRow(row2, colKey, value) {
    var newRow = _objectSpread({}, row2);

    set_1(newRow, colKey, value);
    return newRow;
  };

  var currentRow = React.useMemo(function () {
    return getCurrentRow(row, col.colKey, editValue);
  }, [col.colKey, editValue, row]);
  var cellNode = React.useMemo(function () {
    var node = table_TR.renderCell({
      row: currentRow,
      col: _objectSpread(_objectSpread({}, col), {}, {
        cell: props.oldCell
      }),
      rowIndex: props.rowIndex,
      colIndex: props.colIndex
    }, {
      cellEmptyContent: props.cellEmptyContent
    });
    return node;
  }, [col, currentRow, props.cellEmptyContent, props.colIndex, props.oldCell, props.rowIndex]);
  var componentProps = React.useMemo(function () {
    var _edit$abortEditOnEven;

    var edit = col.edit;
    if (!edit) return {};
    var editProps = isFunction.isFunction_1(edit.props) ? edit.props({
      col: col,
      row: row,
      rowIndex: rowIndex,
      colIndex: colIndex,
      editedRow: currentRow
    }) : _objectSpread({}, edit.props);
    delete editProps.onChange;
    delete editProps.value;
    (_edit$abortEditOnEven = edit.abortEditOnEvent) === null || _edit$abortEditOnEven === void 0 ? void 0 : _edit$abortEditOnEven.forEach(function (item) {
      delete editProps[item];
    });
    return editProps;
  }, [col, colIndex, currentRow, row, rowIndex]);
  var isAbortEditOnChange = React.useMemo(function () {
    var _edit$abortEditOnEven2;

    var edit = col.edit;
    if (!edit) return false;
    return Boolean((_edit$abortEditOnEven2 = edit.abortEditOnEvent) === null || _edit$abortEditOnEven2 === void 0 ? void 0 : _edit$abortEditOnEven2.includes("onChange"));
  }, [col]);

  var validateEdit = function validateEdit(trigger) {
    return new Promise(function (resolve) {
      var cellParams = {
        col: props.col,
        row: props.row,
        colIndex: props.colIndex,
        rowIndex: props.rowIndex
      };
      var params = {
        result: [_objectSpread(_objectSpread({}, cellParams), {}, {
          errorList: [],
          value: editValue
        })],
        trigger: trigger
      };
      var rules = isFunction.isFunction_1(col.edit.rules) ? col.edit.rules(cellParams) : col.edit.rules;

      if (!col.edit || !rules || !rules.length) {
        var _props$onValidate;

        (_props$onValidate = props.onValidate) === null || _props$onValidate === void 0 ? void 0 : _props$onValidate.call(props, params);
        resolve(true);
        return;
      }

      form_formModel.validate(editValue, rules).then(function (result) {
        var _props$onValidate2;

        var list = result === null || result === void 0 ? void 0 : result.filter(function (t) {
          return !t.result;
        });
        params.result[0].errorList = list;
        (_props$onValidate2 = props.onValidate) === null || _props$onValidate2 === void 0 ? void 0 : _props$onValidate2.call(props, params);

        if (!list || !list.length) {
          resolve(true);
        } else {
          setErrorList(list);
          resolve(list);
        }
      });
    });
  };

  var isSame = function isSame(a, b) {
    if (_typeof._typeof(a) === "object" && _typeof._typeof(b) === "object") {
      return JSON.stringify(a) === JSON.stringify(b);
    }

    return a === b;
  };

  var updateAndSaveAbort = function updateAndSaveAbort(outsideAbortEvent) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    validateEdit("self").then(function (result) {
      if (result !== true) return;
      var oldValue = get.get_1(row, col.colKey);

      if (!isSame(args[0].value, oldValue)) {
        setEditValue(oldValue);
        outsideAbortEvent === null || outsideAbortEvent === void 0 ? void 0 : outsideAbortEvent.apply(void 0, args);
      }

      var timer = setTimeout(function () {
        setIsEdit(false);
        setErrorList([]);
        clearTimeout(timer);
      }, 0);
    });
  };

  var listeners = React.useMemo(function () {
    var _edit$abortEditOnEven3;

    var edit = col.edit;
    var isCellEditable = props.editable === void 0;
    if (!isEdit || !isCellEditable) return;
    if (!(edit !== null && edit !== void 0 && (_edit$abortEditOnEven3 = edit.abortEditOnEvent) !== null && _edit$abortEditOnEven3 !== void 0 && _edit$abortEditOnEven3.length)) return {};
    var tListeners = {};
    var outsideAbortEvent = edit === null || edit === void 0 ? void 0 : edit.onEdited;
    edit.abortEditOnEvent.forEach(function (itemEvent) {
      if (itemEvent === "onChange") return;

      tListeners[itemEvent] = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        updateAndSaveAbort.apply(void 0, [outsideAbortEvent, {
          value: editValue,
          trigger: itemEvent,
          newRowData: currentRow,
          rowIndex: props.rowIndex
        }].concat(args));
      };
    });
    return tListeners;
  }, [col, currentRow, isEdit, props.rowIndex]);

  var onEditChange = function onEditChange(val) {
    var _props$onChange, _props$onRuleChange;

    setEditValue(val);
    var params = {
      row: props.row,
      rowIndex: props.rowIndex,
      value: val,
      col: props.col,
      colIndex: props.colIndex,
      editedRow: _objectSpread(_objectSpread({}, props.row), {}, defineProperty._defineProperty({}, props.col.colKey, val))
    };
    (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, params);
    (_props$onRuleChange = props.onRuleChange) === null || _props$onRuleChange === void 0 ? void 0 : _props$onRuleChange.call(props, params);
    var isCellEditable = props.editable === void 0;

    if (isCellEditable && isAbortEditOnChange) {
      var _col$edit;

      var outsideAbortEvent = (_col$edit = col.edit) === null || _col$edit === void 0 ? void 0 : _col$edit.onEdited;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      updateAndSaveAbort.apply(void 0, [outsideAbortEvent, {
        value: val,
        trigger: "onChange",
        newRowData: getCurrentRow(currentRow, col.colKey, val),
        rowIndex: props.rowIndex
      }].concat(args));
    }
  };

  var documentClickHandler = function documentClickHandler(e) {
    var _e$path, _tableEditableCellRef;

    if (!col.edit || !col.edit.component) return;
    if (!isEdit) return;
    if ((_e$path = e.path) !== null && _e$path !== void 0 && _e$path.includes(tableEditableCellRef === null || tableEditableCellRef === void 0 ? void 0 : (_tableEditableCellRef = tableEditableCellRef.current) === null || _tableEditableCellRef === void 0 ? void 0 : _tableEditableCellRef.currentElement)) return;
    var outsideAbortEvent = col.edit.onEdited;
    updateAndSaveAbort(outsideAbortEvent, {
      value: editValue,
      trigger: "document",
      newRowData: currentRow,
      rowIndex: props.rowIndex
    });
  };

  var cellValue = React.useMemo(function () {
    return get.get_1(row, col.colKey);
  }, [row, col.colKey]);
  React.useEffect(function () {
    var val = cellValue;

    if (_typeof._typeof(val) === "object" && val !== null) {
      val = val instanceof Array ? toConsumableArray._toConsumableArray(val) : _objectSpread({}, val);
    }

    setEditValue(val);
  }, [cellValue]);
  React.useEffect(function () {
    var isCellEditable = props.editable === void 0;
    if (!col.edit || !col.edit.component || !isCellEditable) return;

    if (isEdit) {
      document.addEventListener("click", documentClickHandler);
    } else {
      document.removeEventListener("click", documentClickHandler);
    }

    return function () {
      document.removeEventListener("click", documentClickHandler);
    };
  }, [col.edit, isEdit, editValue]);
  React.useEffect(function () {
    if (props.editable === false) {
      setEditValue(cellValue);
    }
  }, [cellValue, editable]);
  React.useEffect(function () {
    if (props.editable === true) {
      var _props$onRuleChange2;

      (_props$onRuleChange2 = props.onRuleChange) === null || _props$onRuleChange2 === void 0 ? void 0 : _props$onRuleChange2.call(props, {
        col: col,
        row: row,
        rowIndex: rowIndex,
        colIndex: colIndex,
        value: cellValue,
        editedRow: row
      });
    }
  }, [cellValue, col, colIndex, row, rowIndex]);
  React.useEffect(function () {
    setErrorList(errors);
  }, [errors]);

  if (props.readonly) {
    return cellNode || null;
  }

  if (props.editable === void 0 && !isEdit || editable === false) {
    var _col$edit2;

    return /* @__PURE__ */React__default["default"].createElement("div", {
      className: classNames__default["default"](tableBaseClass.cellEditable),
      onClick: function onClick(e) {
        setIsEdit(true);
        e.stopPropagation();
      }
    }, cellNode, ((_col$edit2 = col.edit) === null || _col$edit2 === void 0 ? void 0 : _col$edit2.showEditIcon) !== false && /* @__PURE__ */React__default["default"].createElement(Edit1Icon, {
      size: "12px"
    }));
  }

  var Component = (_col$edit3 = col.edit) === null || _col$edit3 === void 0 ? void 0 : _col$edit3.component;

  if (!Component) {
    _common_js_log_log["default"].error("Table", "edit.component is required.");
    return null;
  }

  var errorMessage = errorList === null || errorList === void 0 ? void 0 : (_errorList$ = errorList[0]) === null || _errorList$ === void 0 ? void 0 : _errorList$.message;
  return /* @__PURE__ */React__default["default"].createElement("div", {
    className: tableBaseClass.cellEditWrap,
    onClick: function onClick(e) {
      e.stopPropagation();
    }
  }, /* @__PURE__ */React__default["default"].createElement(Component, _objectSpread(_objectSpread(_objectSpread({
    ref: tableEditableCellRef,
    status: errorMessage ? (errorList === null || errorList === void 0 ? void 0 : (_errorList$2 = errorList[0]) === null || _errorList$2 === void 0 ? void 0 : _errorList$2.type) || "error" : void 0,
    tips: errorMessage
  }, componentProps), listeners), {}, {
    value: editValue,
    onChange: onEditChange
  })));
};

EditableCell.displayName = "EditableCell";

exports["default"] = EditableCell;
//# sourceMappingURL=EditableCell.js.map
