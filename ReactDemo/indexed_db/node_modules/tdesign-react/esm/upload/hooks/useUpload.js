/**
 * tdesign v0.41.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from '../../_chunks/dep-1e32006c.js';
import { _ as _toConsumableArray } from '../../_chunks/dep-59b9253f.js';
import { _ as _slicedToArray } from '../../_chunks/dep-9615f03f.js';
import { useRef, useState, useMemo } from 'react';
import { m as merge_1 } from '../../_chunks/dep-13a70a46.js';
import { getTriggerTextField, getDisplayFiles, validateFile, getFilesAndErrors, upload } from '../../_common/js/upload/main.js';
import { getFileUrlByFileRaw } from '../../_common/js/upload/utils.js';
import useControlled from '../../hooks/useControlled.js';
import useConfig from '../../hooks/useConfig.js';
import { useLocaleReceiver } from '../../locale/LocalReceiver.js';
import '../../_chunks/dep-7909fefa.js';
import '../../_chunks/dep-d1b4ab24.js';
import '../../_chunks/dep-1cce5a60.js';
import '../../_chunks/dep-dc1ce7ed.js';
import '../../_chunks/dep-4e2181de.js';
import '../../_chunks/dep-c197ce4f.js';
import '../../_chunks/dep-e430e2ee.js';
import '../../_chunks/dep-4a64abb1.js';
import '../../_chunks/dep-4e0da095.js';
import '../../_chunks/dep-e54bb0dc.js';
import '../../_chunks/dep-b2626e28.js';
import '../../_chunks/dep-5a2778c1.js';
import '../../_chunks/dep-a2b97df8.js';
import '../../_chunks/dep-7aeeb170.js';
import '../../_chunks/dep-2afd805c.js';
import '../../_chunks/dep-e237f0f2.js';
import '../../_chunks/dep-4ed2dce5.js';
import '../../_chunks/dep-c8db35c0.js';
import '../../_chunks/dep-96aef4a9.js';
import '../../_chunks/dep-557a1b0f.js';
import '../../_chunks/dep-264b0e55.js';
import '../../_chunks/dep-f5693bf6.js';
import '../../_chunks/dep-fdd1d1a6.js';
import '../../_chunks/dep-7ff8b18e.js';
import '../../_chunks/dep-ebf3a272.js';
import '../../_chunks/dep-6a2482c6.js';
import '../../_chunks/dep-a980ac05.js';
import '../../locale/zh_CN.js';
import '../../_common/js/global-config/locale/zh_CN.js';
import '../../_common/js/global-config/default-config.js';
import '../../_common/js/upload/xhr.js';
import '../../_common/js/log/log.js';
import '../../_chunks/dep-f54ff1e5.js';
import '../../_chunks/dep-e1d4dd61.js';
import '../../_chunks/dep-236ef238.js';
import '../../_chunks/dep-c8bfa11e.js';
import '../../_chunks/dep-199b1581.js';
import '../../_util/noop.js';
import '../../config-provider/index.js';
import '../../config-provider/ConfigProvider.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function useUpload(props) {
  var inputRef = useRef();
  var disabled = props.disabled,
      autoUpload = props.autoUpload,
      isBatchUpload = props.isBatchUpload;

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var _useLocaleReceiver = useLocaleReceiver("upload"),
      _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 2),
      globalLocale = _useLocaleReceiver2[0],
      t = _useLocaleReceiver2[1];

  var _useControlled = useControlled(props, "files", props.onChange),
      _useControlled2 = _slicedToArray(_useControlled, 2),
      uploadValue = _useControlled2[0],
      setUploadValue = _useControlled2[1];

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      xhrReq = _useState2[0],
      setXhrReq = _useState2[1];

  var _useState3 = useState([]),
      _useState4 = _slicedToArray(_useState3, 2),
      toUploadFiles = _useState4[0],
      setToUploadFiles = _useState4[1];

  var _useState5 = useState(""),
      _useState6 = _slicedToArray(_useState5, 2),
      sizeOverLimitMessage = _useState6[0],
      setSizeOverLimitMessage = _useState6[1];

  var locale = useMemo(function () {
    return merge_1({}, globalLocale, props.locale);
  }, [globalLocale, props.locale]);
  var tipsClasses = "".concat(classPrefix, "-upload__tips ").concat(classPrefix, "-size-s");
  var errorClasses = [tipsClasses].concat("".concat(classPrefix, "-upload__tips-error"));
  var triggerUploadText = useMemo(function () {
    var _uploadValue$;

    var field = getTriggerTextField({
      isBatchUpload: props.isBatchUpload,
      multiple: props.multiple,
      status: uploadValue === null || uploadValue === void 0 ? void 0 : (_uploadValue$ = uploadValue[0]) === null || _uploadValue$ === void 0 ? void 0 : _uploadValue$.status,
      autoUpload: props.autoUpload
    });
    return locale.triggerUploadText[field];
  }, [locale.triggerUploadText, uploadValue, props.multiple, props.isBatchUpload, props.autoUpload]);

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      uploading = _useState8[0],
      setUploading = _useState8[1];

  var displayFiles = useMemo(function () {
    return getDisplayFiles({
      multiple: props.multiple,
      toUploadFiles: toUploadFiles,
      uploadValue: uploadValue,
      autoUpload: autoUpload,
      isBatchUpload: isBatchUpload
    });
  }, [props.multiple, toUploadFiles, uploadValue, autoUpload, isBatchUpload]);

  var onResponseError = function onResponseError(p) {
    var _props$onOneFileFail;

    if (!p) return;
    var response = p.response,
        event = p.event,
        files = p.files;
    (files === null || files === void 0 ? void 0 : files[0]) && ((_props$onOneFileFail = props.onOneFileFail) === null || _props$onOneFileFail === void 0 ? void 0 : _props$onOneFileFail.call(props, {
      e: event,
      file: files === null || files === void 0 ? void 0 : files[0],
      currentFiles: files,
      failedFiles: files,
      response: response
    }));
  };

  var onResponseProgress = function onResponseProgress(p) {
    var _props$onProgress;

    (_props$onProgress = props.onProgress) === null || _props$onProgress === void 0 ? void 0 : _props$onProgress.call(props, {
      e: p.event,
      file: p.file,
      currentFiles: p.files,
      percent: p.percent,
      type: p.type
    });
  };

  var onResponseSuccess = function onResponseSuccess(p) {
    var _props$onOneFileSucce;

    if (!props.multiple || props.uploadAllFilesInOneRequest) return;
    (_props$onOneFileSucce = props.onOneFileSuccess) === null || _props$onOneFileSucce === void 0 ? void 0 : _props$onOneFileSucce.call(props, {
      e: p.event,
      file: p.files[0],
      response: p.response
    });
    var index = uploadValue.findIndex(function (file) {
      return file.raw === p.files[0].raw;
    });

    if (index > 0) {
      uploadValue.splice(index, 1, p.files[0]);
      setUploadValue(_toConsumableArray(uploadValue), {
        trigger: "status-change"
      });
    }
  };

  function getSizeLimitError(sizeLimitObj) {
    var limit = sizeLimitObj;
    return limit.message ? t(limit.message, {
      sizeLimit: limit.size
    }) : "".concat(t(locale.sizeLimitMessage, {
      sizeLimit: limit.size
    }), " ").concat(limit.unit);
  }

  var handleNonAutoUpload = function handleNonAutoUpload(toFiles) {
    var tmpFiles = props.multiple && !props.isBatchUpload ? uploadValue.concat(toFiles) : toFiles;

    if (["image", "image-flow"].includes(props.theme)) {
      var list = tmpFiles.map(function (file) {
        return new Promise(function (resolve) {
          getFileUrlByFileRaw(file.raw).then(function (url) {
            resolve(_objectSpread(_objectSpread({}, file), {}, {
              url: url
            }));
          });
        });
      });
      Promise.all(list).then(function (files) {
        setUploadValue(files, {
          trigger: "add",
          index: uploadValue.length,
          file: files[0]
        });
      });
    } else {
      setUploadValue(tmpFiles, {
        trigger: "add",
        index: uploadValue.length,
        file: tmpFiles[0]
      });
    }

    setToUploadFiles([]);
  };

  var onFileChange = function onFileChange(files) {
    var _props$onSelectChange;

    if (props.disabled) return;
    (_props$onSelectChange = props.onSelectChange) === null || _props$onSelectChange === void 0 ? void 0 : _props$onSelectChange.call(props, _toConsumableArray(files), {
      currentSelectedFiles: toUploadFiles
    });
    validateFile({
      uploadValue: uploadValue,
      files: _toConsumableArray(files),
      allowUploadDuplicateFile: props.allowUploadDuplicateFile,
      max: props.max,
      sizeLimit: props.sizeLimit,
      isBatchUpload: props.isBatchUpload,
      autoUpload: props.autoUpload,
      format: props.format,
      beforeUpload: props.beforeUpload,
      beforeAllFilesUpload: props.beforeAllFilesUpload
    }).then(function (args) {
      var _args$validateResult;

      if (((_args$validateResult = args.validateResult) === null || _args$validateResult === void 0 ? void 0 : _args$validateResult.type) === "BEFORE_ALL_FILES_UPLOAD") return;

      if (args.lengthOverLimit) {
        var _props$onValidate;

        (_props$onValidate = props.onValidate) === null || _props$onValidate === void 0 ? void 0 : _props$onValidate.call(props, {
          type: "FILES_OVER_LENGTH_LIMIT",
          files: args.files
        });
      }

      if (args.hasSameNameFile) {
        var _props$onValidate2;

        (_props$onValidate2 = props.onValidate) === null || _props$onValidate2 === void 0 ? void 0 : _props$onValidate2.call(props, {
          type: "FILTER_FILE_SAME_NAME",
          files: args.files
        });
      }

      if (args.fileValidateList instanceof Array) {
        var _props$onWaitingUploa;

        var _getFilesAndErrors = getFilesAndErrors(args.fileValidateList, getSizeLimitError),
            sizeLimitErrors = _getFilesAndErrors.sizeLimitErrors,
            toFiles = _getFilesAndErrors.toFiles;

        var tmpWaitingFiles = autoUpload ? toFiles : toUploadFiles.concat(toFiles);
        setToUploadFiles(tmpWaitingFiles);
        (_props$onWaitingUploa = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa === void 0 ? void 0 : _props$onWaitingUploa.call(props, {
          files: tmpWaitingFiles,
          trigger: "validate"
        });

        if (sizeLimitErrors[0]) {
          var _props$onValidate3;

          setSizeOverLimitMessage(sizeLimitErrors[0].file.response.error);
          (_props$onValidate3 = props.onValidate) === null || _props$onValidate3 === void 0 ? void 0 : _props$onValidate3.call(props, {
            type: "FILE_OVER_SIZE_LIMIT",
            files: sizeLimitErrors.map(function (t2) {
              return t2.file;
            })
          });
        }

        setSizeOverLimitMessage("");

        if (autoUpload) {
          uploadFiles(toFiles);
        } else {
          handleNonAutoUpload(toFiles);
        }
      }
    });
    inputRef.current.value = null;
  };

  var onNormalFileChange = function onNormalFileChange(e) {
    onFileChange === null || onFileChange === void 0 ? void 0 : onFileChange(e.target.files);
  };

  function onDragFileChange(e) {
    onFileChange === null || onFileChange === void 0 ? void 0 : onFileChange(e.dataTransfer.files);
  }

  var xhrReqList = [];

  function uploadFiles(toFiles) {
    var notUploadedFiles = uploadValue.filter(function (t2) {
      return t2.status !== "success";
    });
    var files = props.autoUpload ? toFiles || toUploadFiles : notUploadedFiles;
    if (!files || !files.length) return;
    setUploading(true);
    upload({
      action: props.action,
      uploadedFiles: uploadValue,
      toUploadFiles: files,
      multiple: props.multiple,
      isBatchUpload: props.isBatchUpload,
      uploadAllFilesInOneRequest: props.uploadAllFilesInOneRequest,
      useMockProgress: props.useMockProgress,
      data: props.data,
      requestMethod: props.requestMethod,
      formatRequest: props.formatRequest,
      formatResponse: props.formatResponse,
      onResponseProgress: onResponseProgress,
      onResponseSuccess: onResponseSuccess,
      onResponseError: onResponseError,
      setXhrObject: function setXhrObject(xhr) {
        var _xhr$files$;

        if ((_xhr$files$ = xhr.files[0]) !== null && _xhr$files$ !== void 0 && _xhr$files$.raw && xhrReqList.find(function (item) {
          return item.files[0].raw === xhr.files[0].raw;
        })) return;
        xhrReqList = xhrReqList.concat(xhr);
        var timer = setTimeout(function () {
          setXhrReq(xhrReqList);
          clearTimeout(timer);
        }, 10);
      }
    }).then(function (_ref) {
      var status = _ref.status,
          data = _ref.data,
          list = _ref.list,
          failedFiles = _ref.failedFiles;
      setUploading(false);

      if (status === "success") {
        var _props$onSuccess;

        if (props.autoUpload) {
          setUploadValue(data.files, {
            e: data.event,
            trigger: "add",
            index: uploadValue.length,
            file: data.files[0]
          });
        }

        (_props$onSuccess = props.onSuccess) === null || _props$onSuccess === void 0 ? void 0 : _props$onSuccess.call(props, {
          fileList: data.files,
          currentFiles: files,
          file: files[0],
          results: list === null || list === void 0 ? void 0 : list.map(function (t2) {
            return t2.data;
          })
        });
        xhrReqList = [];
        setXhrReq([]);
      } else if (failedFiles !== null && failedFiles !== void 0 && failedFiles[0]) {
        var _props$onFail;

        (_props$onFail = props.onFail) === null || _props$onFail === void 0 ? void 0 : _props$onFail.call(props, {
          e: data.event,
          file: failedFiles[0],
          failedFiles: failedFiles,
          currentFiles: files,
          response: data.response
        });
      }

      if (props.autoUpload) {
        var _props$onWaitingUploa2;

        setToUploadFiles(failedFiles);
        (_props$onWaitingUploa2 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa2 === void 0 ? void 0 : _props$onWaitingUploa2.call(props, {
          files: failedFiles,
          trigger: "uploaded"
        });
      }
    }, function (p) {
      onResponseError(p);
      setUploading(false);
    });
  }

  function onRemove(p) {
    var _props$onRemove2;

    setSizeOverLimitMessage("");
    var changePrams = {
      e: p.e,
      trigger: "remove",
      index: p.index,
      file: p.file
    };

    if (!p.file && p.index === -1) {
      var _props$onWaitingUploa3, _props$onRemove;

      setToUploadFiles([]);
      (_props$onWaitingUploa3 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa3 === void 0 ? void 0 : _props$onWaitingUploa3.call(props, {
        files: [],
        trigger: "remove"
      });
      setUploadValue([], changePrams);
      (_props$onRemove = props.onRemove) === null || _props$onRemove === void 0 ? void 0 : _props$onRemove.call(props, p);
      return;
    }

    if (autoUpload && p.file.status !== "success") {
      var _props$onWaitingUploa4;

      toUploadFiles.splice(p.index, 1);
      setToUploadFiles(_toConsumableArray(toUploadFiles));
      (_props$onWaitingUploa4 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa4 === void 0 ? void 0 : _props$onWaitingUploa4.call(props, {
        files: _toConsumableArray(toUploadFiles),
        trigger: "remove"
      });

      if (p.file.raw || p.file.name) {
        var fileIndex = uploadValue.findIndex(function (file) {
          return file.raw && file.raw === p.file.raw || file.name && file.name === p.file.name;
        });

        if (fileIndex !== -1) {
          uploadValue.splice(fileIndex, 1);
          setUploadValue(_toConsumableArray(uploadValue), changePrams);
        }
      }
    } else {
      uploadValue.splice(p.index, 1);
      setUploadValue(_toConsumableArray(uploadValue), changePrams);
    }

    (_props$onRemove2 = props.onRemove) === null || _props$onRemove2 === void 0 ? void 0 : _props$onRemove2.call(props, p);
  }

  var triggerUpload = function triggerUpload() {
    if (disabled) return;
    inputRef.current.click();
  };

  var cancelUpload = function cancelUpload(context) {
    xhrReq === null || xhrReq === void 0 ? void 0 : xhrReq.forEach(function (item) {
      var _item$xhrReq;

      (_item$xhrReq = item.xhrReq) === null || _item$xhrReq === void 0 ? void 0 : _item$xhrReq.abort();
    });
    setUploading(false);

    if (props.autoUpload) {
      setToUploadFiles(toUploadFiles.map(function (item) {
        return _objectSpread(_objectSpread({}, item), {}, {
          status: "waiting"
        });
      }));
    } else {
      setUploadValue(uploadValue.map(function (item) {
        if (item.status !== "success") {
          return _objectSpread(_objectSpread({}, item), {}, {
            status: "waiting"
          });
        }

        return item;
      }), {
        trigger: "abort"
      });
    }

    if (context !== null && context !== void 0 && context.file) {
      onRemove === null || onRemove === void 0 ? void 0 : onRemove({
        file: context.file,
        e: context.e,
        index: 0
      });
    }
  };

  return {
    t: t,
    locale: locale,
    classPrefix: classPrefix,
    triggerUploadText: triggerUploadText,
    toUploadFiles: toUploadFiles,
    uploadValue: uploadValue,
    displayFiles: displayFiles,
    sizeOverLimitMessage: sizeOverLimitMessage,
    uploading: uploading,
    tipsClasses: tipsClasses,
    errorClasses: errorClasses,
    inputRef: inputRef,
    disabled: disabled,
    xhrReq: xhrReq,
    uploadFiles: uploadFiles,
    onFileChange: onFileChange,
    onNormalFileChange: onNormalFileChange,
    onDragFileChange: onDragFileChange,
    onRemove: onRemove,
    triggerUpload: triggerUpload,
    cancelUpload: cancelUpload
  };
}

export { useUpload as default };
//# sourceMappingURL=useUpload.js.map
