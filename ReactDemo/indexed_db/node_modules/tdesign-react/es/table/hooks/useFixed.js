/**
 * tdesign v0.41.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _slicedToArray } from '../../_chunks/dep-9615f03f.js';
import { _ as _defineProperty } from '../../_chunks/dep-1e32006c.js';
import { useState, useRef, useMemo, useEffect } from 'react';
import { g as get_1 } from '../../_chunks/dep-ddb0f1c1.js';
import { getIEVersion } from '../../_common/js/utils/helper.js';
import '../../_common/js/log/index.js';
import getScrollbarWidth from '../../_common/js/utils/getScrollbarWidth.js';
import { off, on } from '../../_util/dom.js';
import useDebounce from '../../hooks/useDebounce.js';
import log from '../../_common/js/log/log.js';
import '../../_chunks/dep-7909fefa.js';
import '../../_chunks/dep-1cce5a60.js';
import '../../_chunks/dep-93a10d8c.js';
import '../../_chunks/dep-264b0e55.js';
import '../../_chunks/dep-4e0da095.js';
import '../../_chunks/dep-199b1581.js';
import '../../_chunks/dep-4a64abb1.js';
import '../../_chunks/dep-e237f0f2.js';
import '../../_chunks/dep-4e2181de.js';
import '../../_chunks/dep-c197ce4f.js';
import '../../_chunks/dep-e430e2ee.js';
import '../../_chunks/dep-e54bb0dc.js';
import '../../_chunks/dep-b2626e28.js';
import '../../_chunks/dep-5a2778c1.js';
import '../../_chunks/dep-a2b97df8.js';
import '../../_chunks/dep-c8bfa11e.js';
import '../../_chunks/dep-59b9253f.js';
import '../../_chunks/dep-d1b4ab24.js';
import '../../_chunks/dep-8368bb87.js';
import 'raf';
import '../../_chunks/dep-3c98169f.js';
import '../../_util/easing.js';
import 'lodash';
import '../../_util/usePersistFn.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function getColumnFixedStyles(col, index, rowAndColFixedPosition, tableColFixedClasses) {
  var _thClasses;

  var fixedPos = rowAndColFixedPosition === null || rowAndColFixedPosition === void 0 ? void 0 : rowAndColFixedPosition.get(col.colKey || index);
  if (!fixedPos) return {};
  var thClasses = (_thClasses = {}, _defineProperty(_thClasses, tableColFixedClasses.left, col.fixed === "left"), _defineProperty(_thClasses, tableColFixedClasses.right, col.fixed === "right"), _defineProperty(_thClasses, tableColFixedClasses.lastLeft, col.fixed === "left" && fixedPos.lastLeftFixedCol), _defineProperty(_thClasses, tableColFixedClasses.firstRight, col.fixed === "right" && fixedPos.firstRightFixedCol), _thClasses);
  var thStyles = {
    left: col.fixed === "left" ? "".concat(fixedPos.left, "px") : void 0,
    right: col.fixed === "right" ? "".concat(fixedPos.right, "px") : void 0
  };
  return {
    style: thStyles,
    classes: thClasses
  };
}
function getRowFixedStyles(rowId, rowIndex, rowLength, fixedRows, rowAndColFixedPosition, tableRowFixedClasses) {
  var _rowClasses;

  if (!fixedRows || !fixedRows.length) return {
    style: void 0,
    classes: void 0
  };
  var fixedTop = rowIndex < fixedRows[0];
  var fixedBottom = rowIndex > rowLength - 1 - fixedRows[1];
  var firstFixedBottomRow = rowLength - fixedRows[1];
  var fixedPos = (rowAndColFixedPosition === null || rowAndColFixedPosition === void 0 ? void 0 : rowAndColFixedPosition.get(rowId)) || {};
  var rowClasses = (_rowClasses = {}, _defineProperty(_rowClasses, tableRowFixedClasses.top, fixedTop), _defineProperty(_rowClasses, tableRowFixedClasses.bottom, fixedBottom), _defineProperty(_rowClasses, tableRowFixedClasses.firstBottom, rowIndex === firstFixedBottomRow), _defineProperty(_rowClasses, tableRowFixedClasses.withoutBorderBottom, rowIndex === firstFixedBottomRow - 1), _rowClasses);
  var rowStyles = {
    top: fixedTop ? "".concat(fixedPos.top, "px") : void 0,
    bottom: fixedBottom ? "".concat(fixedPos.bottom, "px") : void 0
  };
  return {
    style: rowStyles,
    classes: rowClasses
  };
}
function useFixed(props, finalColumns) {
  var _props$scroll2;

  var columns = props.columns,
      tableLayout = props.tableLayout,
      tableContentWidth = props.tableContentWidth,
      fixedRows = props.fixedRows,
      firstFullRow = props.firstFullRow,
      lastFullRow = props.lastFullRow,
      maxHeight = props.maxHeight,
      headerAffixedTop = props.headerAffixedTop,
      bordered = props.bordered;

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      data = _useState2[0],
      setData = _useState2[1];

  var tableContentRef = useRef();

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isFixedHeader = _useState4[0],
      setIsFixedHeader = _useState4[1];

  var _useState5 = useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      isWidthOverflow = _useState6[0],
      setIsWidthOverflow = _useState6[1];

  var tableElmRef = useRef();

  var _useState7 = useState(6),
      _useState8 = _slicedToArray(_useState7, 2),
      scrollbarWidth = _useState8[0],
      setScrollbarWidth = _useState8[1];

  var _useState9 = useState( /* @__PURE__ */new Map()),
      _useState10 = _slicedToArray(_useState9, 2),
      rowAndColFixedPosition = _useState10[0],
      setRowAndColFixedPosition = _useState10[1];

  var _useState11 = useState({
    left: false,
    right: false
  }),
      _useState12 = _slicedToArray(_useState11, 2),
      showColumnShadow = _useState12[0],
      setShowColumnShadow = _useState12[1];

  var _useState13 = useState({
    left: 0,
    top: 0
  }),
      _useState14 = _slicedToArray(_useState13, 2),
      virtualScrollHeaderPos = _useState14[0],
      setVirtualScrollHeaderPos = _useState14[1];

  var tableWidth = useRef(0);
  var tableElmWidth = useRef(0);
  var thWidthList = useRef({});

  var _useState15 = useState(false),
      _useState16 = _slicedToArray(_useState15, 2),
      isFixedColumn = _useState16[0],
      setIsFixedColumn = _useState16[1];

  var columnResizable = useMemo(function () {
    return props.resizable || false;
  }, [props.resizable]);
  var notNeedThWidthList = useMemo(function () {
    var _props$scroll;

    return !(props.headerAffixedTop || props.footerAffixedBottom || props.horizontalScrollAffixedBottom || ((_props$scroll = props.scroll) === null || _props$scroll === void 0 ? void 0 : _props$scroll.type) === "virtual");
  }, [props.footerAffixedBottom, props.headerAffixedTop, props.horizontalScrollAffixedBottom, (_props$scroll2 = props.scroll) === null || _props$scroll2 === void 0 ? void 0 : _props$scroll2.type]);
  var recalculateColWidth = useRef(null);

  function setUseFixedTableElmRef(val) {
    tableElmRef.current = val;
  }

  function setRecalculateColWidthFuncRef(val) {
    recalculateColWidth.current = val;
  }

  function getColumnMap(columns2) {
    var map = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();
    var levelNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var parent = arguments.length > 4 ? arguments[4] : undefined;

    for (var i = 0, len = columns2.length; i < len; i++) {
      var _col$children;

      var col = columns2[i];

      if (["left", "right"].includes(col.fixed)) {
        setIsFixedColumn(true);
      }

      var key = col.colKey || i;
      var columnInfo = {
        col: col,
        parent: parent,
        index: i
      };
      map.set(key, columnInfo);

      if ((_col$children = col.children) !== null && _col$children !== void 0 && _col$children.length) {
        getColumnMap(col.children, map, levelNodes, level + 1, columnInfo);
      }

      if (levelNodes[level]) {
        levelNodes[level].push(columnInfo);
      } else {
        levelNodes[level] = [columnInfo];
      }
    }

    return {
      newColumnsMap: map,
      levelNodes: levelNodes
    };
  }

  var setFixedLeftPos = function setFixedLeftPos(columns2, initialColumnMap) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var i = 0, len = columns2.length; i < len; i++) {
      var _col$children2;

      var col = columns2[i];
      if (col.fixed === "right") return;
      var colInfo = initialColumnMap.get(col.colKey || i);
      var lastColIndex = i - 1;

      while (lastColIndex >= 0 && columns2[lastColIndex].fixed !== "left") {
        lastColIndex -= 1;
      }

      var lastCol = columns2[lastColIndex];
      var defaultWidth = i === 0 ? (parent === null || parent === void 0 ? void 0 : parent.left) || 0 : 0;
      var lastColInfo = initialColumnMap.get((lastCol === null || lastCol === void 0 ? void 0 : lastCol.colKey) || i - 1);
      colInfo.left = ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.left) || defaultWidth) + ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.width) || 0);

      if ((_col$children2 = col.children) !== null && _col$children2 !== void 0 && _col$children2.length) {
        setFixedLeftPos(col.children, initialColumnMap, colInfo);
      }
    }
  };

  var setFixedRightPos = function setFixedRightPos(columns2, initialColumnMap) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var i = columns2.length - 1; i >= 0; i--) {
      var _col$children3;

      var col = columns2[i];
      if (col.fixed === "left") return;
      var colInfo = initialColumnMap.get(col.colKey || i);
      var lastColIndex = i + 1;

      while (lastColIndex < columns2.length && columns2[lastColIndex].fixed !== "right") {
        lastColIndex += 1;
      }

      var lastCol = columns2[lastColIndex];
      var defaultWidth = i === columns2.length - 1 ? (parent === null || parent === void 0 ? void 0 : parent.right) || 0 : 0;
      var lastColInfo = initialColumnMap.get((lastCol === null || lastCol === void 0 ? void 0 : lastCol.colKey) || i + 1);
      colInfo.right = ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.right) || defaultWidth) + ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.width) || 0);

      if ((_col$children3 = col.children) !== null && _col$children3 !== void 0 && _col$children3.length) {
        setFixedRightPos(col.children, initialColumnMap, colInfo);
      }
    }
  };

  var setFixedColPosition = function setFixedColPosition(trList, initialColumnMap) {
    if (!trList) return;

    for (var i = 0, len = trList.length; i < len; i++) {
      var thList = trList[i].children;

      for (var j = 0, thLen = thList.length; j < thLen; j++) {
        var _obj$col;

        var th = thList[j];
        var colKey = th.dataset.colkey;

        if (!colKey) {
          log.warn("TDesign Table", "".concat(th.innerText, " missing colKey. colKey is required for fixed column feature."));
        }

        var obj = initialColumnMap.get(colKey || j);

        if (obj !== null && obj !== void 0 && (_obj$col = obj.col) !== null && _obj$col !== void 0 && _obj$col.fixed) {
          var _th$getBoundingClient;

          initialColumnMap.set(colKey, _objectSpread(_objectSpread({}, obj), {}, {
            width: th === null || th === void 0 ? void 0 : (_th$getBoundingClient = th.getBoundingClientRect) === null || _th$getBoundingClient === void 0 ? void 0 : _th$getBoundingClient.call(th).width
          }));
        }
      }
    }

    setFixedLeftPos(columns, initialColumnMap);
    setFixedRightPos(columns, initialColumnMap);
  };

  var setFixedRowPosition = function setFixedRowPosition(trList, initialColumnMap, thead, tfoot) {
    var _ref = fixedRows || [],
        _ref2 = _slicedToArray(_ref, 2),
        fixedTopRows = _ref2[0],
        fixedBottomRows = _ref2[1];

    var data2 = props.data,
        _props$rowKey = props.rowKey,
        rowKey = _props$rowKey === void 0 ? "id" : _props$rowKey;

    for (var i = 0; i < fixedTopRows; i++) {
      var _tr$getBoundingClient;

      var tr = trList[i];
      var rowId = get_1(data2[i], rowKey);
      var thisRowInfo = initialColumnMap.get(rowId) || {};
      var lastRowId = get_1(data2[i - 1], rowKey);
      var lastRowInfo = initialColumnMap.get(lastRowId) || {};
      var defaultBottom = 0;

      if (i === 0) {
        var _thead$getBoundingCli;

        defaultBottom = (thead === null || thead === void 0 ? void 0 : (_thead$getBoundingCli = thead.getBoundingClientRect) === null || _thead$getBoundingCli === void 0 ? void 0 : _thead$getBoundingCli.call(thead).height) || 0;
      }

      thisRowInfo.top = (lastRowInfo.top || defaultBottom) + (lastRowInfo.height || 0);
      initialColumnMap.set(rowId, _objectSpread(_objectSpread({}, thisRowInfo), {}, {
        height: tr === null || tr === void 0 ? void 0 : (_tr$getBoundingClient = tr.getBoundingClientRect) === null || _tr$getBoundingClient === void 0 ? void 0 : _tr$getBoundingClient.call(tr).height
      }));
    }

    for (var _i = data2.length - 1; _i >= data2.length - fixedBottomRows; _i--) {
      var _tr$getBoundingClient2;

      var _tr = trList[_i];

      var _rowId = get_1(data2[_i], rowKey);

      var _thisRowInfo = initialColumnMap.get(_rowId) || {};

      var _lastRowId = get_1(data2[_i + 1], rowKey);

      var _lastRowInfo = initialColumnMap.get(_lastRowId) || {};

      var _defaultBottom = 0;

      if (_i === data2.length - 1) {
        var _tfoot$getBoundingCli;

        _defaultBottom = (tfoot === null || tfoot === void 0 ? void 0 : (_tfoot$getBoundingCli = tfoot.getBoundingClientRect) === null || _tfoot$getBoundingCli === void 0 ? void 0 : _tfoot$getBoundingCli.call(tfoot).height) || 0;
      }

      _thisRowInfo.bottom = (_lastRowInfo.bottom || _defaultBottom) + (_lastRowInfo.height || 0);
      initialColumnMap.set(_rowId, _objectSpread(_objectSpread({}, _thisRowInfo), {}, {
        height: _tr === null || _tr === void 0 ? void 0 : (_tr$getBoundingClient2 = _tr.getBoundingClientRect) === null || _tr$getBoundingClient2 === void 0 ? void 0 : _tr$getBoundingClient2.call(_tr).height
      }));
    }
  };

  var updateRowAndColFixedPosition = function updateRowAndColFixedPosition(tableContentElm, initialColumnMap) {
    rowAndColFixedPosition.clear();
    if (!tableContentElm) return;
    var thead = tableContentElm.querySelector("thead");
    thead && setFixedColPosition(thead.children, initialColumnMap);
    var tbody = tableContentElm.querySelector("tbody");
    var tfoot = tableContentElm.querySelector("tfoot");
    tbody && setFixedRowPosition(tbody.children, initialColumnMap, thead, tfoot);
    setRowAndColFixedPosition(initialColumnMap);
  };

  var shadowLastScrollLeft;

  var updateColumnFixedShadow = function updateColumnFixedShadow(target, extra) {
    if (!isFixedColumn || !target) return;
    var scrollLeft = target.scrollLeft;
    if (shadowLastScrollLeft === scrollLeft && (!extra || !extra.skipScrollLimit)) return;
    shadowLastScrollLeft = scrollLeft;
    var isShowRight = target.clientWidth + scrollLeft < target.scrollWidth;
    setShowColumnShadow({
      left: scrollLeft > 0,
      right: isShowRight
    });
  };

  var setIsLastOrFirstFixedCol = function setIsLastOrFirstFixedCol(levelNodes) {
    for (var t = 0; t < levelNodes.length; t++) {
      var nodes = levelNodes[t];

      for (var i = 0, len = nodes.length; i < len; i++) {
        var colMapInfo = nodes[i];
        var nextColMapInfo = nodes[i + 1];
        var parent = colMapInfo.parent;
        var isParentLastLeftFixedCol = !parent || (parent === null || parent === void 0 ? void 0 : parent.lastLeftFixedCol);

        if (isParentLastLeftFixedCol && colMapInfo.col.fixed === "left" && (nextColMapInfo === null || nextColMapInfo === void 0 ? void 0 : nextColMapInfo.col.fixed) !== "left") {
          colMapInfo.lastLeftFixedCol = true;
        }

        var lastColMapInfo = nodes[i - 1];
        var isParentFirstRightFixedCol = !parent || (parent === null || parent === void 0 ? void 0 : parent.firstRightFixedCol);

        if (isParentFirstRightFixedCol && colMapInfo.col.fixed === "right" && (lastColMapInfo === null || lastColMapInfo === void 0 ? void 0 : lastColMapInfo.col.fixed) !== "right") {
          colMapInfo.firstRightFixedCol = true;
        }
      }
    }
  };

  var updateFixedStatus = function updateFixedStatus() {
    var _getColumnMap = getColumnMap(columns),
        newColumnsMap = _getColumnMap.newColumnsMap,
        levelNodes = _getColumnMap.levelNodes;

    setIsLastOrFirstFixedCol(levelNodes);
    var timer = setTimeout(function () {
      if (isFixedColumn || fixedRows !== null && fixedRows !== void 0 && fixedRows.length) {
        updateRowAndColFixedPosition(tableContentRef.current, newColumnsMap);
      }

      clearTimeout(timer);
    }, 0);
    return function () {
      clearTimeout(timer);
    };
  };

  var updateFixedHeader = function updateFixedHeader() {
    var timer = setTimeout(function () {
      var _tRef$getBoundingClie;

      var tRef = tableContentRef === null || tableContentRef === void 0 ? void 0 : tableContentRef.current;
      if (!tRef) return;
      setIsFixedHeader(tRef.scrollHeight > tRef.clientHeight);
      setIsWidthOverflow(tRef.scrollWidth > tRef.clientWidth);
      var pos = tRef === null || tRef === void 0 ? void 0 : (_tRef$getBoundingClie = tRef.getBoundingClientRect) === null || _tRef$getBoundingClie === void 0 ? void 0 : _tRef$getBoundingClie.call(tRef);
      setVirtualScrollHeaderPos({
        top: pos === null || pos === void 0 ? void 0 : pos.top,
        left: pos === null || pos === void 0 ? void 0 : pos.left
      });
      clearTimeout(timer);
    }, 0);
  };

  var updateTableWidth = function updateTableWidth() {
    var _tableContentRef$curr, _tableContentRef$curr2, _tableElmRef$current;

    var rect = (_tableContentRef$curr = tableContentRef.current) === null || _tableContentRef$curr === void 0 ? void 0 : (_tableContentRef$curr2 = _tableContentRef$curr.getBoundingClientRect) === null || _tableContentRef$curr2 === void 0 ? void 0 : _tableContentRef$curr2.call(_tableContentRef$curr);
    if (!rect) return;
    var reduceWidth = isFixedHeader ? scrollbarWidth : 0;
    tableWidth.current = rect.width - reduceWidth - (props.bordered ? 1 : 0);
    var elmRect = tableElmRef === null || tableElmRef === void 0 ? void 0 : (_tableElmRef$current = tableElmRef.current) === null || _tableElmRef$current === void 0 ? void 0 : _tableElmRef$current.getBoundingClientRect();
    tableElmWidth.current = elmRect === null || elmRect === void 0 ? void 0 : elmRect.width;
  };

  var updateThWidthList = function updateThWidthList(trList) {
    if (trList instanceof HTMLCollection) {
      if (columnResizable) return;
      var widthMap = {};

      for (var i = 0, len = trList.length; i < len; i++) {
        var thList = trList[i].children;

        for (var j = 0, thLen = thList.length; j < thLen; j++) {
          var _th$getBoundingClient2;

          var th = thList[j];
          var colKey = th.dataset.colkey;
          widthMap[colKey] = th === null || th === void 0 ? void 0 : (_th$getBoundingClient2 = th.getBoundingClientRect) === null || _th$getBoundingClient2 === void 0 ? void 0 : _th$getBoundingClient2.call(th).width;
        }
      }

      thWidthList.current = widthMap;
    } else {
      Object.entries(trList).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            colKey = _ref4[0],
            width = _ref4[1];

        thWidthList.current[colKey] = width;
      });
    }
  };

  var updateThWidthListHandler = function updateThWidthListHandler() {
    if (columnResizable && recalculateColWidth.current) {
      recalculateColWidth.current(finalColumns, thWidthList.current, tableLayout, tableElmWidth.current);
    }

    if (notNeedThWidthList) return;
    var timer = setTimeout(function () {
      var _tableContentRef$curr3;

      updateTableWidth();
      var thead = (_tableContentRef$curr3 = tableContentRef.current) === null || _tableContentRef$curr3 === void 0 ? void 0 : _tableContentRef$curr3.querySelector("thead");
      if (!thead) return;
      updateThWidthList(thead.children);
      clearTimeout(timer);
    }, 0);
  };

  var resetThWidthList = function resetThWidthList() {
    thWidthList.current = {};
  };

  var emitScrollEvent = function emitScrollEvent(e) {
    var _props$onScrollX, _props$onScrollY, _props$onScroll;

    (_props$onScrollX = props.onScrollX) === null || _props$onScrollX === void 0 ? void 0 : _props$onScrollX.call(props, {
      e: e
    });
    (_props$onScrollY = props.onScrollY) === null || _props$onScrollY === void 0 ? void 0 : _props$onScrollY.call(props, {
      e: e
    });
    (_props$onScroll = props.onScroll) === null || _props$onScroll === void 0 ? void 0 : _props$onScroll.call(props, {
      e: e
    });
  };

  var getThWidthList = function getThWidthList() {
    return thWidthList.current || {};
  };

  useEffect(updateFixedStatus, [data, columns, bordered, tableLayout, tableContentWidth, isFixedHeader, isWidthOverflow, isFixedColumn, fixedRows, firstFullRow, lastFullRow, tableContentRef]);
  useEffect(function () {
    var timer = setTimeout(function () {
      if (isFixedColumn) {
        updateColumnFixedShadow(tableContentRef.current);
      }

      clearTimeout(timer);
    }, 0);
  }, [isFixedColumn, columns, tableContentRef]);
  useEffect(updateFixedHeader, [maxHeight, data, columns, bordered, tableContentRef]);
  useEffect(function () {
    resetThWidthList();

    if (columnResizable) {
      recalculateColWidth.current(finalColumns, thWidthList.current, tableLayout, tableElmWidth.current);
    }
  }, [finalColumns]);
  useEffect(updateThWidthListHandler, [data, columns, bordered, tableLayout, fixedRows, isFixedHeader, headerAffixedTop, tableContentWidth, notNeedThWidthList, tableContentRef]);
  var refreshTable = useDebounce(function () {
    updateTableWidth();
    updateFixedHeader();
    updateThWidthListHandler();

    if (isFixedColumn || isFixedHeader) {
      updateFixedStatus();
      updateColumnFixedShadow(tableContentRef.current, {
        skipScrollLimit: true
      });
    }
  }, 30);
  var onResize = refreshTable;

  function addTableResizeObserver(tableElement) {
    if (getIEVersion() < 11 || typeof window.ResizeObserver === "undefined") return;
    off(window, "resize", onResize);
    var resizeObserver = new window.ResizeObserver(function () {
      refreshTable();
    });
    resizeObserver.observe(tableElement);
    return function () {
      resizeObserver.unobserve(tableElement);
      resizeObserver.disconnect();
    };
  }

  useEffect(function () {
    var scrollWidth = getScrollbarWidth();
    setScrollbarWidth(scrollWidth);
    var isWatchResize = isFixedColumn || isFixedHeader || !notNeedThWidthList || !data.length;
    var timer = setTimeout(function () {
      updateTableWidth();

      if (columnResizable && recalculateColWidth.current) {
        recalculateColWidth.current(finalColumns, thWidthList.current, tableLayout, tableElmWidth.current);
      }

      if (isWatchResize && getIEVersion() < 11 || typeof window.ResizeObserver === "undefined") {
        on(window, "resize", onResize);
      }

      clearTimeout(timer);
    });
    return function () {
      if (isWatchResize && getIEVersion() < 11 || typeof window.ResizeObserver === "undefined") {
        off(window, "resize", onResize);
      }

      clearTimeout(timer);
    };
  }, [isFixedColumn]);
  return {
    tableWidth: tableWidth,
    tableElmWidth: tableElmWidth,
    thWidthList: thWidthList,
    isFixedHeader: isFixedHeader,
    isWidthOverflow: isWidthOverflow,
    tableContentRef: tableContentRef,
    isFixedColumn: isFixedColumn,
    showColumnShadow: showColumnShadow,
    rowAndColFixedPosition: rowAndColFixedPosition,
    virtualScrollHeaderPos: virtualScrollHeaderPos,
    scrollbarWidth: scrollbarWidth,
    setData: setData,
    refreshTable: refreshTable,
    emitScrollEvent: emitScrollEvent,
    updateThWidthListHandler: updateThWidthListHandler,
    updateColumnFixedShadow: updateColumnFixedShadow,
    setUseFixedTableElmRef: setUseFixedTableElmRef,
    getThWidthList: getThWidthList,
    updateThWidthList: updateThWidthList,
    setRecalculateColWidthFuncRef: setRecalculateColWidthFuncRef,
    addTableResizeObserver: addTableResizeObserver
  };
}

export { useFixed as default, getColumnFixedStyles, getRowFixedStyles };
//# sourceMappingURL=useFixed.js.map
