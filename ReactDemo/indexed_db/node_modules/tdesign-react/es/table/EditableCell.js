/**
 * tdesign v0.41.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _toConsumableArray } from '../_chunks/dep-59b9253f.js';
import { _ as _typeof } from '../_chunks/dep-4e0da095.js';
import { _ as _defineProperty } from '../_chunks/dep-1e32006c.js';
import { _ as _slicedToArray } from '../_chunks/dep-9615f03f.js';
import React, { useRef, useState, useMemo, useEffect } from 'react';
import { g as get_1 } from '../_chunks/dep-ddb0f1c1.js';
import '../_chunks/dep-1cce5a60.js';
import { _ as _baseSet } from '../_chunks/dep-afbd242f.js';
import { i as isFunction_1 } from '../_chunks/dep-e430e2ee.js';
import { Edit1Icon } from 'tdesign-icons-react';
import classNames from 'classnames';
import useGlobalIcon from '../hooks/useGlobalIcon.js';
import { renderCell } from './TR.js';
import { validate } from '../form/formModel.js';
import '../_common/js/log/index.js';
import log from '../_common/js/log/log.js';
import '../_chunks/dep-7909fefa.js';
import '../_chunks/dep-d1b4ab24.js';
import '../_chunks/dep-93a10d8c.js';
import '../_chunks/dep-264b0e55.js';
import '../_chunks/dep-199b1581.js';
import '../_chunks/dep-4a64abb1.js';
import '../_chunks/dep-e237f0f2.js';
import '../_chunks/dep-4e2181de.js';
import '../_chunks/dep-c197ce4f.js';
import '../_chunks/dep-5a2778c1.js';
import '../_chunks/dep-e54bb0dc.js';
import '../_chunks/dep-b2626e28.js';
import '../_chunks/dep-a2b97df8.js';
import '../_chunks/dep-c8bfa11e.js';
import '../_chunks/dep-c8db35c0.js';
import '../_chunks/dep-96aef4a9.js';
import '../_chunks/dep-f5693bf6.js';
import '../hooks/useConfig.js';
import '../_chunks/dep-13a70a46.js';
import '../_chunks/dep-dc1ce7ed.js';
import '../_chunks/dep-7aeeb170.js';
import '../_chunks/dep-2afd805c.js';
import '../_chunks/dep-4ed2dce5.js';
import '../_chunks/dep-557a1b0f.js';
import '../_chunks/dep-fdd1d1a6.js';
import '../_chunks/dep-7ff8b18e.js';
import '../_chunks/dep-ebf3a272.js';
import '../_chunks/dep-6a2482c6.js';
import '../_chunks/dep-a980ac05.js';
import '../locale/zh_CN.js';
import '../_common/js/global-config/locale/zh_CN.js';
import '../_common/js/global-config/default-config.js';
import './utils.js';
import './hooks/useFixed.js';
import '../_common/js/utils/helper.js';
import '../_chunks/dep-8368bb87.js';
import '../_common/js/utils/getScrollbarWidth.js';
import '../_util/dom.js';
import 'raf';
import '../_chunks/dep-3c98169f.js';
import '../_util/easing.js';
import '../hooks/useDebounce.js';
import 'lodash';
import '../_util/usePersistFn.js';
import './hooks/useClassName.js';
import './Ellipsis.js';
import '../tooltip/index.js';
import '../tooltip/Tooltip.js';
import '../popup/index.js';
import '../popup/Popup.js';
import 'react-transition-group';
import 'react-popper';
import '../hooks/useControlled.js';
import '../_chunks/dep-f54ff1e5.js';
import '../_chunks/dep-e1d4dd61.js';
import '../_chunks/dep-236ef238.js';
import '../_util/noop.js';
import '../_util/useAnimation.js';
import '../common/Portal.js';
import 'react-dom';
import '../popup/hooks/useTrigger.js';
import 'react-is';
import '../popup/utils/ref.js';
import '../_util/composeRefs.js';
import '../popup/utils/transition.js';
import '../_util/useMutationObserver.js';
import '../_chunks/dep-236b0359.js';
import '../_chunks/dep-6d5c0a90.js';
import '../_util/useWindowSize.js';
import '../popup/defaultProps.js';
import '../popup/style/css.js';
import '../popup/type.js';
import '../tooltip/defaultProps.js';
import '../tooltip/style/css.js';
import '../tooltip/type.js';
import './hooks/useLazyLoad.js';
import '../_common/js/utils/observe.js';
import './hooks/useRowspanAndColspan.js';
import '../_chunks/dep-ece048b5.js';
import '../_chunks/dep-ea78983d.js';
import '../_chunks/dep-614f9a08.js';
import '../_chunks/dep-a5f8b6ec.js';

var baseSet = _baseSet;
/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */

function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

var set_1 = set;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var EditableCell = function EditableCell(props) {
  var _props$col$edit, _col$edit3, _errorList$, _errorList$2;

  var row = props.row,
      col = props.col,
      rowIndex = props.rowIndex,
      colIndex = props.colIndex,
      errors = props.errors,
      editable = props.editable,
      tableBaseClass = props.tableBaseClass;

  var _useGlobalIcon = useGlobalIcon({
    Edit1Icon: Edit1Icon
  }),
      Edit1Icon$1 = _useGlobalIcon.Edit1Icon;

  var tableEditableCellRef = useRef(null);

  var _useState = useState(((_props$col$edit = props.col.edit) === null || _props$col$edit === void 0 ? void 0 : _props$col$edit.defaultEditable) || false),
      _useState2 = _slicedToArray(_useState, 2),
      isEdit = _useState2[0],
      setIsEdit = _useState2[1];

  var _useState3 = useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      editValue = _useState4[0],
      setEditValue = _useState4[1];

  var _useState5 = useState([]),
      _useState6 = _slicedToArray(_useState5, 2),
      errorList = _useState6[0],
      setErrorList = _useState6[1];

  var getCurrentRow = function getCurrentRow(row2, colKey, value) {
    var newRow = _objectSpread({}, row2);

    set_1(newRow, colKey, value);
    return newRow;
  };

  var currentRow = useMemo(function () {
    return getCurrentRow(row, col.colKey, editValue);
  }, [col.colKey, editValue, row]);
  var cellNode = useMemo(function () {
    var node = renderCell({
      row: currentRow,
      col: _objectSpread(_objectSpread({}, col), {}, {
        cell: props.oldCell
      }),
      rowIndex: props.rowIndex,
      colIndex: props.colIndex
    }, {
      cellEmptyContent: props.cellEmptyContent
    });
    return node;
  }, [col, currentRow, props.cellEmptyContent, props.colIndex, props.oldCell, props.rowIndex]);
  var componentProps = useMemo(function () {
    var _edit$abortEditOnEven;

    var edit = col.edit;
    if (!edit) return {};
    var editProps = isFunction_1(edit.props) ? edit.props({
      col: col,
      row: row,
      rowIndex: rowIndex,
      colIndex: colIndex,
      editedRow: currentRow
    }) : _objectSpread({}, edit.props);
    delete editProps.onChange;
    delete editProps.value;
    (_edit$abortEditOnEven = edit.abortEditOnEvent) === null || _edit$abortEditOnEven === void 0 ? void 0 : _edit$abortEditOnEven.forEach(function (item) {
      delete editProps[item];
    });
    return editProps;
  }, [col, colIndex, currentRow, row, rowIndex]);
  var isAbortEditOnChange = useMemo(function () {
    var _edit$abortEditOnEven2;

    var edit = col.edit;
    if (!edit) return false;
    return Boolean((_edit$abortEditOnEven2 = edit.abortEditOnEvent) === null || _edit$abortEditOnEven2 === void 0 ? void 0 : _edit$abortEditOnEven2.includes("onChange"));
  }, [col]);

  var validateEdit = function validateEdit(trigger) {
    return new Promise(function (resolve) {
      var cellParams = {
        col: props.col,
        row: props.row,
        colIndex: props.colIndex,
        rowIndex: props.rowIndex
      };
      var params = {
        result: [_objectSpread(_objectSpread({}, cellParams), {}, {
          errorList: [],
          value: editValue
        })],
        trigger: trigger
      };
      var rules = isFunction_1(col.edit.rules) ? col.edit.rules(cellParams) : col.edit.rules;

      if (!col.edit || !rules || !rules.length) {
        var _props$onValidate;

        (_props$onValidate = props.onValidate) === null || _props$onValidate === void 0 ? void 0 : _props$onValidate.call(props, params);
        resolve(true);
        return;
      }

      validate(editValue, rules).then(function (result) {
        var _props$onValidate2;

        var list = result === null || result === void 0 ? void 0 : result.filter(function (t) {
          return !t.result;
        });
        params.result[0].errorList = list;
        (_props$onValidate2 = props.onValidate) === null || _props$onValidate2 === void 0 ? void 0 : _props$onValidate2.call(props, params);

        if (!list || !list.length) {
          resolve(true);
        } else {
          setErrorList(list);
          resolve(list);
        }
      });
    });
  };

  var isSame = function isSame(a, b) {
    if (_typeof(a) === "object" && _typeof(b) === "object") {
      return JSON.stringify(a) === JSON.stringify(b);
    }

    return a === b;
  };

  var updateAndSaveAbort = function updateAndSaveAbort(outsideAbortEvent) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    validateEdit("self").then(function (result) {
      if (result !== true) return;
      var oldValue = get_1(row, col.colKey);

      if (!isSame(args[0].value, oldValue)) {
        setEditValue(oldValue);
        outsideAbortEvent === null || outsideAbortEvent === void 0 ? void 0 : outsideAbortEvent.apply(void 0, args);
      }

      var timer = setTimeout(function () {
        setIsEdit(false);
        setErrorList([]);
        clearTimeout(timer);
      }, 0);
    });
  };

  var listeners = useMemo(function () {
    var _edit$abortEditOnEven3;

    var edit = col.edit;
    var isCellEditable = props.editable === void 0;
    if (!isEdit || !isCellEditable) return;
    if (!(edit !== null && edit !== void 0 && (_edit$abortEditOnEven3 = edit.abortEditOnEvent) !== null && _edit$abortEditOnEven3 !== void 0 && _edit$abortEditOnEven3.length)) return {};
    var tListeners = {};
    var outsideAbortEvent = edit === null || edit === void 0 ? void 0 : edit.onEdited;
    edit.abortEditOnEvent.forEach(function (itemEvent) {
      if (itemEvent === "onChange") return;

      tListeners[itemEvent] = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        updateAndSaveAbort.apply(void 0, [outsideAbortEvent, {
          value: editValue,
          trigger: itemEvent,
          newRowData: currentRow,
          rowIndex: props.rowIndex
        }].concat(args));
      };
    });
    return tListeners;
  }, [col, currentRow, isEdit, props.rowIndex]);

  var onEditChange = function onEditChange(val) {
    var _props$onChange, _props$onRuleChange;

    setEditValue(val);
    var params = {
      row: props.row,
      rowIndex: props.rowIndex,
      value: val,
      col: props.col,
      colIndex: props.colIndex,
      editedRow: _objectSpread(_objectSpread({}, props.row), {}, _defineProperty({}, props.col.colKey, val))
    };
    (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, params);
    (_props$onRuleChange = props.onRuleChange) === null || _props$onRuleChange === void 0 ? void 0 : _props$onRuleChange.call(props, params);
    var isCellEditable = props.editable === void 0;

    if (isCellEditable && isAbortEditOnChange) {
      var _col$edit;

      var outsideAbortEvent = (_col$edit = col.edit) === null || _col$edit === void 0 ? void 0 : _col$edit.onEdited;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      updateAndSaveAbort.apply(void 0, [outsideAbortEvent, {
        value: val,
        trigger: "onChange",
        newRowData: getCurrentRow(currentRow, col.colKey, val),
        rowIndex: props.rowIndex
      }].concat(args));
    }
  };

  var documentClickHandler = function documentClickHandler(e) {
    var _e$path, _tableEditableCellRef;

    if (!col.edit || !col.edit.component) return;
    if (!isEdit) return;
    if ((_e$path = e.path) !== null && _e$path !== void 0 && _e$path.includes(tableEditableCellRef === null || tableEditableCellRef === void 0 ? void 0 : (_tableEditableCellRef = tableEditableCellRef.current) === null || _tableEditableCellRef === void 0 ? void 0 : _tableEditableCellRef.currentElement)) return;
    var outsideAbortEvent = col.edit.onEdited;
    updateAndSaveAbort(outsideAbortEvent, {
      value: editValue,
      trigger: "document",
      newRowData: currentRow,
      rowIndex: props.rowIndex
    });
  };

  var cellValue = useMemo(function () {
    return get_1(row, col.colKey);
  }, [row, col.colKey]);
  useEffect(function () {
    var val = cellValue;

    if (_typeof(val) === "object" && val !== null) {
      val = val instanceof Array ? _toConsumableArray(val) : _objectSpread({}, val);
    }

    setEditValue(val);
  }, [cellValue]);
  useEffect(function () {
    var isCellEditable = props.editable === void 0;
    if (!col.edit || !col.edit.component || !isCellEditable) return;

    if (isEdit) {
      document.addEventListener("click", documentClickHandler);
    } else {
      document.removeEventListener("click", documentClickHandler);
    }

    return function () {
      document.removeEventListener("click", documentClickHandler);
    };
  }, [col.edit, isEdit, editValue]);
  useEffect(function () {
    if (props.editable === false) {
      setEditValue(cellValue);
    }
  }, [cellValue, editable]);
  useEffect(function () {
    if (props.editable === true) {
      var _props$onRuleChange2;

      (_props$onRuleChange2 = props.onRuleChange) === null || _props$onRuleChange2 === void 0 ? void 0 : _props$onRuleChange2.call(props, {
        col: col,
        row: row,
        rowIndex: rowIndex,
        colIndex: colIndex,
        value: cellValue,
        editedRow: row
      });
    }
  }, [cellValue, col, colIndex, row, rowIndex]);
  useEffect(function () {
    setErrorList(errors);
  }, [errors]);

  if (props.readonly) {
    return cellNode || null;
  }

  if (props.editable === void 0 && !isEdit || editable === false) {
    var _col$edit2;

    return /* @__PURE__ */React.createElement("div", {
      className: classNames(tableBaseClass.cellEditable),
      onClick: function onClick(e) {
        setIsEdit(true);
        e.stopPropagation();
      }
    }, cellNode, ((_col$edit2 = col.edit) === null || _col$edit2 === void 0 ? void 0 : _col$edit2.showEditIcon) !== false && /* @__PURE__ */React.createElement(Edit1Icon$1, {
      size: "12px"
    }));
  }

  var Component = (_col$edit3 = col.edit) === null || _col$edit3 === void 0 ? void 0 : _col$edit3.component;

  if (!Component) {
    log.error("Table", "edit.component is required.");
    return null;
  }

  var errorMessage = errorList === null || errorList === void 0 ? void 0 : (_errorList$ = errorList[0]) === null || _errorList$ === void 0 ? void 0 : _errorList$.message;
  return /* @__PURE__ */React.createElement("div", {
    className: tableBaseClass.cellEditWrap,
    onClick: function onClick(e) {
      e.stopPropagation();
    }
  }, /* @__PURE__ */React.createElement(Component, _objectSpread(_objectSpread(_objectSpread({
    ref: tableEditableCellRef,
    status: errorMessage ? (errorList === null || errorList === void 0 ? void 0 : (_errorList$2 = errorList[0]) === null || _errorList$2 === void 0 ? void 0 : _errorList$2.type) || "error" : void 0,
    tips: errorMessage
  }, componentProps), listeners), {}, {
    value: editValue,
    onChange: onEditChange
  })));
};

EditableCell.displayName = "EditableCell";

export { EditableCell as default };
//# sourceMappingURL=EditableCell.js.map
